##Â 2. Faire des statistiques agrÃ©gÃ©es par catÃ©gories

Cette partie permet de calculer en amont de l'application des
statistiques descriptives qui pourront Ãªtre utilisÃ©es
par celle-ci. 

Il est prÃ©fÃ©rable de minimiser la quantitÃ© de calculs
faits Ã  la volÃ©e dans le cadre d'une application. Sinon,
le risque est une latence embÃªtante pour l'utilisateur
voire un crash du serveur Ã  cause de besoins
de ressources trop importants.

Cette partie propose ainsi de crÃ©er en avance deux
bases de donnÃ©es synthÃ©tisant certaines statistiques
descriptives:

- Pour les variables nutritionnelles (calories, glucides, etc.), les
dÃ©ciles de la distribution. Ils permettront de placer notre produit
par rapport Ã  des produits similaires (ceux partageant la mÃªme variable
de catÃ©gorie, crÃ©Ã©e prÃ©cÃ©demment). 
- Pour les notes synthÃ©tiques (nutriscore, score nova et Ã©coscore), le
nombre de produits dans une catÃ©gorie donnÃ©e (par exemple les
fromages Ã  pate crue) qui ont la mÃªme note.

### PrÃ©liminaire (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)


Sur le plan technique, cette partie propose deux cadres de manipulation
de donnÃ©es diffÃ©rents,
selon le balisage de la voie:

- ğŸŸ¡,ğŸŸ¢,ğŸ”µ: utilisation de `Pandas`
- ğŸ”´,âš«: requÃªtes SQL directement sur le fichier `Parquet` grÃ¢ce Ã  `DuckDB`


Cette partie peut Ãªtre faite sans avoir suivie la prÃ©cÃ©dente. 
Il est alors recommandÃ© d'effectuer deux actions:

1. Dans le fichier `config.yaml`, remplacer `"projet-funathon"` par votre nom
d'utilisateur sur le `SSP Cloud`
2. Utiliser la commande suivante pour copier le fichier d'exemple mis Ã  disposition 
vers votre espace personnel :

```{python}
#| eval: false
# remplacer `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud
!mc cp s3/projet-funathon/2023/sujet4/diffusion/openfood.parquet s3/<USERNAME_SSPCLOUD>/2023/sujet4/diffusion/openfood.parquet
```

en remplacant `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud. 

Cette partie va fonctionner en trois temps:

1. Lecture des donnÃ©es `OpenFoodFacts` prÃ©cÃ©demment produites
2. Construction de statistiques descriptives standardisÃ©es
3. Construction de graphiques Ã  partir de ces statistiques descriptives

Les Ã©tapes 1 et 2 sont sÃ©parÃ©es conceptuellement pour les parcours ğŸŸ¡,ğŸŸ¢,ğŸ”µ. 
Pour les parcours ğŸ”´ et âš«, l'utilisation de requÃªtes SQL fait que ces
deux Ã©tapes conceptuelles sont intriquÃ©es. Les parcours ğŸŸ¡,ğŸŸ¢,ğŸ”µ
peuvent observer les morceaux de code proposÃ©s dans le cadre ğŸ”´ et âš«,
c'est assez instructif. 

Nous proposons d'importer Ã  nouveau nos configurations:

```{python}
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
```

Les colonnes suivantes nous seront utiles dans cette partie:

```{python}
info_nutritionnelles = [
    'energy-kcal_100g', 'fat_100g', 'saturated-fat_100g',
    'carbohydrates_100g', 'sugars_100g',
    'proteins_100g', 'salt_100g']
indices_synthetiques = [
    "nutriscore_grade", "ecoscore_grade", "nova_group"
]
principales_infos = ['product_name', 'code', 'preprocessed_labels', 'coicop']
```

Voici, Ã  nouveau, la configuration pour permettre Ã  `Python`
de communiquer avec l'espace de stockage distant:

```{python}
import s3fs

config = import_yaml("config.yaml")
INPUT_OPENFOOD = f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/openfood.parquet"

# Initialisation de la connexion
fs = s3fs.S3FileSystem(
    client_kwargs={"endpoint_url": config["ENDPOINT_S3"]}
)
```



## Import des donnÃ©es depuis l'espace de stockage distant avec `Pandas` (ğŸŸ¡,ğŸŸ¢,ğŸ”µ)

Il est recommandÃ© pour les parcours ğŸŸ¡,ğŸŸ¢,ğŸ”µ de travailler avec `Pandas` pour construire
des statistiques descriptives. Cela se fera en deux Ã©tapes:

- Import des donnÃ©es directement depuis l'espace de stockage, sans Ã©criture intermÃ©diaire sur le disque local,
puis nettoyage de celles-ci ;
- Construction de fonctions standardisÃ©es pour la production de statistiques descriptives.

### Import et nettoyage des donnÃ©es `OpenFoodFacts`

Il est possible de lire un CSV de plusieurs maniÃ¨res avec `Python`.
L'une d'elle se fait Ã  travers le _[context manager](https://book.pythontips.com/en/latest/context_managers.html#context-managers)_. 
Le module `s3fs` permet d'utiliser ce _context manager_ pour lire un fichier distant, 
de maniÃ¨re trÃ¨s similaire Ã  la lecture d'un fichier local. 

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Lire les donnÃ©es depuis un espace distant (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

A partir du _context manager_ intÃ©grÃ© Ã  `s3fs`, lire
les donnÃ©es en suivant les consignes suivantes:

- la localisation des donnÃ©es est stockÃ©e dans la variable `INPUT_OPENFOOD`
- Utiliser l'option `columns = principales_infos + info_nutritionnelles + indices_synthetiques`
pour n'importer que les variables nÃ©cessaires.

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::


::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Lire les donnÃ©es depuis un espace distant (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Lors de l'Ã©criture du fichier nous avons utilisÃ© la commande suivante:

```python
# Ecriture au format parquet sur l'espace de stockage distant
with fs.open(DESTINATION_OPENFOOD, "wb") as file_location:
    openfood.to_parquet(file_location)
```

Nous proposons de suivre la mÃªme logique en changeant quelques Ã©lÃ©ments:

- La variable de chemin Ã  utiliser ici est `INPUT_OPENFOOD` ;
- Le contexte n'est plus Ã  l'Ã©criture (_"wb"_) mais Ã  la lecture (_"rb"_) ;
- La commande Ã  exÃ©cuter dans ce contexte n'est plus l'Ã©criture d'un fichier parquet
mais `pd.read_parquet`. Utiliser
l'option `columns = principales_infos + info_nutritionnelles + indices_synthetiques`
pour n'importer que les variables nÃ©cessaires.

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::


```{python}
#| classes: yellow-code
#| label: get-openfood-parquet
#| output: false

# Solution pour voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
import pandas as pd

# methode 1: pandas
with fs.open(INPUT_OPENFOOD, "rb") as remote_file:
    openfood = pd.read_parquet(
        remote_file,
        columns = principales_infos + \
        info_nutritionnelles + indices_synthetiques
    )
```

Les donnÃ©es ont ainsi l'aspect suivant:

```{python}
openfood.head(2)
```

### Statistiques descriptives (ğŸŸ¡, ğŸŸ¢ et ğŸ”µ)

On va produire deux types de statistiques, pour afficher des graphiques permettant
de placer le produit dans la distribution de produits similaires:

- Distribution pour chaque nutriment d'intÃ©rÃªt (calorie, gras, sucre...) des dÃ©ciles
- Distribution pour chaque score de qualitÃ© (nutriscore, score nova et Ã©coscore) des notes

Vous pouvez observer plus bas un exemple. Ici, on va construire une fois pour toute les
statistiques descriptives. Cela permettra de rÃ©duire les calculs faits par notre application au minimum.

```{python}
data_infos_nutritionnelles = openfood.loc[:,info_nutritionnelles + ["coicop"]]
```


::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Distribution des nutriments par catÃ©gorie de produit (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

CrÃ©er le dataframe `stats_nutritionnelles` de la maniÃ¨re suivante:

1. A partir de `data_infos_nutritionnelles`, regrouper par _"coicop"_ et calculer les quantiles 0.1 ... 0.9
2. Utiliser `reset_index` pour renommer les variables de groupe `coicop` et `quantile`
3. Transformer la variable quantile pour avoir des valeurs entre 1 et 10 plutÃ´t qu'entre 0.1 et 0.9
4. Les donnÃ©es sont au format _wide_ ce qui n'est pas trÃ¨s pratique. On prÃ©fÃ¨re en gÃ©nÃ©ral utiliser le format _long_. Utiliser
la fonction adaptÃ©e pour transformer de _wide_ -> _long_ sur les axes 'coicop' et 'quantile'


```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Distribution des nutriments par catÃ©gorie de produit (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

CrÃ©er le dataframe `stats_nutritionnelles` de la maniÃ¨re suivante:

1. A partir de `data_infos_nutritionnelles`, regrouper par _"coicop"_ et calculer les quantiles 0.1 ... 0.9
grÃ¢ce Ã  la liste `[i/10 for i in range(1,10)]`
2. Utiliser `reset_index(names=['coicop', 'quantile'])` pour renommer les variables de groupe 


```{=html}
<details>
<summary>RÃ©ponse en cas de difficultÃ©</summary>
```

```python
stats_nutritionnelles = data_infos_nutritionnelles.groupby("coicop").quantile([i/10 for i in range(1,10)]).reset_index(names=['coicop', 'quantile'])
```

```{=html}
</details>
```

3. Utiliser la mÃ©thode `mul` pour avoir des quantiles entre 1 et 10 plutÃ´t qu'entre 0.1 et 0.9
4. Les donnÃ©es sont au format _wide_ ce qui n'est pas trÃ¨s pratique. On prÃ©fÃ¨re en gÃ©nÃ©ral utiliser le format _long_. Utiliser
`pd.melt` pour pivoter les donnÃ©es sur les axes 'coicop' et 'quantile'


```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::

Pour obtenir un code modulaire, ce qui prÃ©sente notamment
l'avantage d'Ãªtre plus lisible, nous avons crÃ©Ã© une fonction
qui est prÃ©sente dans le fichier `utils/stats_openfood.py`
dont le code est le suivant:

```{python}
#| classes: yellow-code
#| label: fonction-stats-nutriments
#| output: false

# Solution pour voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
def compute_stats_nutriments(data):
    stats_nutritionnelles = (
        data
        .groupby("coicop")
        .quantile([i/10 for i in range(1,10)])
        .reset_index(names=['coicop', 'quantile'])
    )
    stats_nutritionnelles['quantile'] = stats_nutritionnelles['quantile'].mul(10).astype(int)
    stats_nutritionnelles = pd.melt(stats_nutritionnelles, id_vars=['coicop', 'quantile'])
    return stats_nutritionnelles
```

Celle-ci dÃ©compose, pour chaque classe de produit,
la distribution des nutriments en dix classes. Les donnÃ©es sont ensuite
restructurÃ©es en format _long_ (plus pratique pour l'analyse ultÃ©rieure) 
grÃ¢ce Ã  `pd.melt`.

Cette fonction peut Ãªtre utilisÃ©e de la maniÃ¨re suivante:

```{python}
from utils.stats_openfood import compute_stats_nutriments
stats_nutritionnelles = compute_stats_nutriments(data_infos_nutritionnelles)
```

Nous proposons d'adopter la mÃªme logique pour les notes mais au lieu de faire
des quantiles, on va simplement dÃ©nombrer le nombre d'observations qui ont
cette note dans une classe de produits. 

Nous allons utiliser le `DataFrame` suivant pour les calculs de notes:

```{python}
openfood_notes = openfood.loc[:,["coicop"] + indices_synthetiques]
```

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Distribution des notes par catÃ©gorie de produit (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. AprÃ¨s un `groupby("coicop")`, effectuer un dÃ©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` grÃ¢ce Ã  la mÃ©thode `agg`
puis renommer les deux variables d'index 'coicop' et 'note' grÃ¢ce Ã  la mÃ©thode `reset_index`

```{=html}
<details>
<summary>RÃ©ponse en cas de difficultÃ©</summary>
```

```python
stats_notes = (
    openfood_notes
    .groupby("coicop")
    .agg({i:'value_counts' for i in indices_synthetiques})
    .reset_index(names=['coicop', 'note'])
)
```

```{=html}
</details>

```

2. Utiliser `pd.melt` pour pivoter les donnÃ©es vers un format _long_
via les axes `coicop` et `note`

3. Convertir la colonne `value` obtenue au format `Int64` (qui permet d'avoir
des valeurs manquantes)

4. DÃ©dupliquer les donnÃ©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop` grÃ¢ce Ã  la mÃ©thode `drop_duplicates`

5. Retirer les observations pour lesquelles la variable `note` est Ã©gale
Ã  `unknown`  ou `not-applicable`

6. Pour avoir les notes de toutes les variables sous forme de lettre, utiliser
le code suivant:

```python
stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
    .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
)
```

7. Utiliser la mÃ©thode `str.upper` puis convertir en string avec `astype(str)` 
pour avoir une variable de notes harmonisÃ©es


```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Distribution des notes par catÃ©gorie de produit (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. Pour chaque valeur de la variable `coicop`,
avec la mÃ©thode `agg`, effectuer un dÃ©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` grÃ¢ce Ã  la mÃ©thode `agg`.
Renommer ensuite les deux variables d'index 'coicop' et 'note' grÃ¢ce Ã  la mÃ©thode `reset_index`

2. Pivoter les donnÃ©es vers un format _long_
via les axes `coicop` et `note`

3. Convertir la colonne `value` obtenue au format `Int64` (qui permet d'avoir
des valeurs manquantes)

4. DÃ©dupliquer les donnÃ©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop`

5. Retirer les observations pour lesquelles la variable `note` est Ã©gale
Ã  `unknown`  ou `not-applicable`

6. Pour avoir les notes de toutes les variables sous forme de lettre, utiliser
le code suivant:

```python
stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
    .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
)
```

7. Passer toutes les notes en majuscules puis convertir en string avec `astype(str)` 


```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::


```{python}
# Solution pour voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
def compute_stats_grades(data, indices_synthetiques):
    stats_notes = (
        data
        .groupby("coicop")
        .agg({i:'value_counts' for i in indices_synthetiques})
        .reset_index(names=['coicop', 'note'])
    )
    stats_notes = pd.melt(stats_notes, id_vars = ['coicop','note'])
    stats_notes['note'] = stats_notes['note'].astype(str)
    stats_notes['value'] = stats_notes['value'].astype("Int64")
    stats_notes = stats_notes.dropna().drop_duplicates(subset = ['variable','note','coicop'])
    stats_notes = stats_notes.loc[~stats_notes['note'].isin(['unknown','not-applicable'])]
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
            stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
            .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
        )
    stats_notes['note'] =  stats_notes['note'].str.upper()
    stats_notes['note'] = stats_notes['note'].astype(str)
  
    return stats_notes

stats_notes = compute_stats_grades(openfood_notes, indices_synthetiques)
```

### Statistiques descriptives (ğŸ”´ et âš«)

### Sauvegarde dans l'espace de stockage distant

### CrÃ©ation d'un modÃ¨le de graphiques

On va utiliser `plotly` pour crÃ©er des graphiques et, ultÃ©rieurement,
les afficher sur notre page web. Cela permettra d'avoir un peu de
rÃ©activitÃ©

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Distribution des notes par catÃ©gorie de produit (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```


TO DO


```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::


```{python}
# Solution pour voie ğŸŸ¡
import numpy as np
import plotly.express as px

def figure_infos_nutritionnelles(
    data, variable_nutritionnelle = 'energy-kcal_100g',
    coicop = "01.1.7.3.2", valeur_produit = 8
    ):
    
    example_coicop = data.loc[data['variable'] == variable_nutritionnelle]
    example_coicop = example_coicop.loc[example_coicop['coicop']==coicop]
    example_coicop['color'] = np.where(example_coicop['quantile'] == valeur_produit, "red", "royalblue")

    fig = px.bar(
        example_coicop,
        x='quantile', y='value', color = "color", template = "simple_white",
        title=variable,
        labels={
            "quantile": "",
            "value": "Par portion de 100g"
        }
    )
    fig.update_layout(showlegend=False)
    fig.update_layout(hovermode="x")
    fig.update_traces(
        hovertemplate="<br>".join([
            "DixiÃ¨me nÂ° %{x}",
            f"{variable}: " + " au moins %{y} par portion de 100g"
        ])
    )
    return fig
```

```{python}
figure_infos_nutritionnelles(stats_nutritionnelles).show()
```

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Distribution des notes par catÃ©gorie de produit (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```


TO DO


```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::


```{python}
import plotly.express as px
import numpy as np

def figure_infos_notes(
    data, variable_note = 'nutriscore_grade',
    coicop = "01.1.7.3.2", note_produit = "B"
):
    example_coicop = data.loc[data['variable'] == variable_note]
    example_coicop = example_coicop.loc[stats_notes['coicop']==coicop]
    example_coicop['color'] = np.where(example_coicop['note'] == note_produit, "red", "royalblue")

    fig = px.bar(
        example_coicop,
        x='note', y='value', color = "color", template = "simple_white",
        title=variable,
        labels={
            "note": "Note",
            "value": ""
        }
    )
    fig.update_xaxes(
        categoryorder='array',
        categoryarray= ['A', 'B', 'C', 'D', 'E'])
    fig.update_layout(showlegend=False)
    fig.update_layout(hovermode="x")
    fig.update_traces(
        hovertemplate="<br>".join([
            "Note %{x}",
            f"{variable}: " +" %{y} produits"
        ])
    )

    return fig
```

```{python}
from construct_figures import figure_infos_notes
figure_infos_notes(stats_notes).show()
```