# 3. Comparer un produit √† un groupe similaire

Tout ce travail pr√©liminaire nous permettra d'afficher sur notre application des statistiques
propres √† chaque cat√©gorie.

## Travail pr√©liminaire

```{python}
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")

INPUT_OPENFOOD = f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/openfood.parquet"
```

```{python}
info_nutritionnelles = [
    'energy-kcal_100g', 'fat_100g', 'saturated-fat_100g',
    'carbohydrates_100g', 'sugars_100g',
    'proteins_100g', 'salt_100g']
indices_synthetiques = [
    "nutriscore_grade", "ecoscore_grade", "nova_group"
]
principales_infos = ['product_name', 'code', 'preprocessed_labels', 'coicop']
liste_colonnes = principales_infos + indices_synthetiques + info_nutritionnelles
liste_colonnes_sql = [f"\"{s}\"" for s in liste_colonnes]
liste_colonnes_sql = ', '.join(liste_colonnes_sql)
```

## D√©tection de code barre

La premi√®re brique de notre application consiste √† rep√©rer un produit par le scan du code-barre. 
Nous allons partir pour le moment d'un produit d'exemple, ci-dessous: 

![](https://images.openfoodfacts.org/images/products/500/011/260/2791/front_fr.4.400.jpg)

```{python}
url_image = "https://images.openfoodfacts.org/images/products/500/011/260/2791/front_fr.4.400.jpg"
```

Dans le cadre de notre application, on permettra aux utilisateurs d'_uploader_ 
la photo d'un produit, ce sera plus _fun_.
En attendant, partir d'un produit standardis√©
permet d√©j√† de mettre en oeuvre la logique √† r√©-appliquer plus tard. 

Pour se simplifier la vie, le plus simple pour rep√©rer un code-barre est d'utiliser
le _package_ [`pyzbar`](https://pypi.org/project/pyzbar/).
Pour transformer une image en
matrice `Numpy` (l'objet attendu par [`pyzbar`](https://pypi.org/project/pyzbar/)),
on peut utiliser le module `skimage` de la mani√®re suivante:

```{python}
from skimage import io
io.imread(url_image)
```

::: {.cell .markdown}
<!----- boite üü¢üîµüî¥ et ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Extraire le code-barre √† partir d'une image (üü¢üîµüî¥ et ‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Apr√®s avoir import√© l'image via `io.imread`, utiliser `pyzbar.decode`
pour extraire les informations voulues, notamment le code-barre
2. Si vous avez nomm√© l'objet g√©n√©r√©, v√©rifier le code-barre avec
`obj[0].data.decode()`
3. A partir de cela, cr√©er une fonction `extract_ean` pour d√©coder l'image
(en retournant l'objet g√©n√©r√© par `pyzbar`)

```{=html}
</details>
</div>
```

<!----- end üü¢üîµüî¥ et ‚ö´ ----->
:::

```{python}
#| classes: yellow-code
#| label: get-openfood-parquet
#| output: false
#| eval: false

# Solution pour voie üü°
def extract_ean(url, verbose=True):
    img = io.imread(url)
    decoded_objects = pyzbar.decode(img)
    if verbose is True:
        for obj in decoded_objects:
            # draw the barcode
            print("detected barcode:", obj)
            # print barcode type & data
            print("Type:", obj.type)
            print("Data:", obj.data)
    return decoded_objects

obj = extract_ean(url_image)

obj[0].data.decode()
```


```{python}
#| echo: false
from utils.detect_barcode import extract_ean
extract_ean(url_image)
```


## Association d'un code barre √† un produit d'openfoodfacts


Maintenant qu'on dispose d'un code-barre (le num√©ro EAN), 
on va trouver le produit dans `OpenFoodFacts`
√† partir de ce code barre.

Cependant, comme il peut arriver
qu'un produit dispose d'informations incompl√®tes, 
il peut √™tre utile de faire non seulement de l'apparimeent
exact (trouver le produit avec le m√™me code EAN) mais aussi de
l'appariement flou (trouver un produit avec un nom proche de celui qu'on
veut). Ceci est un exercice pour les parcours üî¥ et ‚ö´, les autres
voies pouvant prendre cette fonction comme donn√©e. 

Voici l'EAN d'exemple

```{python}
ean = "5000112602999"
```

Pour avoir un outil performant, on propose d'utiliser √†
`DuckDB` pour lire et filtrer les donn√©es. Cela sera plus performant que 
lire, √† chaque fois que l'utilisateur de notre applicatoin _upload_ une image,
un gros fichier (2 millions de ligne) pour n'en garder qu'une. 

Voici la configuration √† mettre en oeuvre:

```{python}
import duckdb
con = duckdb.connect(database=':memory:')
con.execute("""
    INSTALL httpfs;
    LOAD httpfs;
    SET s3_endpoint='minio.lab.sspcloud.fr'
""")

from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
url_data = "https://projet-funathon.minio.lab.sspcloud.fr/2023/sujet4/diffusion/openfood.parquet"
```


::: {.cell .markdown}
<!----- boite üü¢üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Lire les donn√©es avec `DuckDB` (üü¢ et üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>

Pour ex√©cuter une requ√™te SQL, on utilise la structure suivante avec `DuckDB`

```python
data_pandas_from_duckdb = con.sql(REQUETE).df()
```

La requ√™te que nous proposons d'utiliser est √† structurer √† partir des √©l√©ments suivants :

- Pour la clause `SELECT`, la liste des colonnes √† utiliser est pr√©-formatt√©e dans l'objet `liste_colonnes_sql`
- Pour la clause `FROM`, l'instruction `read_parquet` peut √™tre utilis√©e avec l'URL stock√© dans `url_data`
- Pour la clause WHERE, vous pouvez utiliser la syntaxe suivante pour normaliser les code-barres des deux c√¥t√©s en retirant les 
0 initiaux: `CAST(ltrim(code, '0') AS STRING) = CAST(ltrim({ean}) AS STRING)`

```{=html}
</details>
</div>
```

<!----- end üü¢üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥ et ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Lire les donn√©es avec `DuckDB` (üî¥ et ‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>

La requ√™te que nous proposons d'utiliser est √† structurer √† partir des √©l√©ments suivants :

- Ne garder que les variables pr√©sentes dans `liste_colonnes_sql`
- Lire les donn√©es directement depuis `url_data`
- Filtrer les donn√©es pour ne garder que celle dans l'OpenFood avec notre code-barre

Aide pour la voie üî¥

Il faut normaliser les code-barres des deux c√¥t√©s avant d'essayer
de comparer. Cela se fait de la mani√®re suivante: `CAST(ltrim({ean}) AS STRING)`
A vous de mettre en oeuvre cela pour faire de la comparaison entre notre EAN et la
variable `code` 



```{=html}
</details>
</div>
```

<!----- end üî¥ et ‚ö´ ----->
:::


```{python}
#| classes: yellow-code
#| label: get-openfood-sql
#| output: false

# Solution pour voie üü°
openfood_produit = con.sql(f"SELECT {liste_colonnes_sql} FROM read_parquet('{url_data}') WHERE CAST(ltrim(code, '0') AS STRING) = CAST(ltrim({ean}) AS STRING)").df()
```

```{python}
product_name = openfood_produit["product_name"].iloc[0]
```

```{python}
import pandas as pd

def fuzzy_matching_product(product_name, con, url_data, liste_colonnes_sql, info_nutritionnelles):
    out_textual = con.sql(f"SELECT {liste_colonnes_sql} from read_parquet('{url_data}') WHERE jaro_winkler_similarity('{product_name}',product_name) > 0.8 AND \"energy-kcal_100g\" IS NOT NULL")
    out_textual = out_textual.df()

    out_textual_imputed = pd.concat(
        [
            openfood_produit.loc[:, ["code", "product_name", "coicop"]].reset_index(drop = True),
            pd.DataFrame(out_textual.loc[:, info_nutritionnelles ].mean()).T
        ], ignore_index=True, axis=1
    )
    out_textual_imputed.columns = ["code", "product_name", "coicop"] + info_nutritionnelles
    
    return out_textual_imputed
```


```{python}
from utils.download_pb import import_coicop_labels
coicop = import_coicop_labels(
    "https://www.insee.fr/fr/statistiques/fichier/2402696/coicop2016_liste_n5.xls"
)
```


```{python}
if openfood_produit['energy-kcal_100g'].isnull().iloc[0]:
    openfood_produit = fuzzy_matching_product(product_name, con, url_data, liste_colonnes_sql, info_nutritionnelles)
    openfood_produit = openfood_produit.merge(coicop, left_on = "coicop", right_on = "Code")
```

```{python}
openfood_produit
```

```{python}
#| eval: false
import requests

url_api = f"https://api.lab.sspcloud.fr/predicat/label?k=1&q=%27{product_name}%27"
url_api = url_api.replace(" ", "%20")


output_api_predicat = requests.get(url_api).json()
coicop_found = output_api_predicat['coicop'][f"'{product_name}'"][0]['label']
coicop_found
```
