# 3Ô∏è‚É£ Comparer un produit √† un groupe similaire

Tout ce travail pr√©liminaire nous permettra d'afficher sur notre application des statistiques
propres √† chaque cat√©gorie.

## Travail pr√©liminaire

On propose d'utiliser le jeu de donn√©es pr√©par√© pr√©cedemment

```{python}

```

```{python}
indices_synthetiques = [
    "nutriscore_grade", "ecoscore_grade", "nova_group"
]
principales_infos = ['product_name', 'code', 'preprocessed_labels', 'coicop']
liste_colonnes = principales_infos + indices_synthetiques
liste_colonnes_sql = [f"\"{s}\"" for s in liste_colonnes]
liste_colonnes_sql = ', '.join(liste_colonnes_sql)
```

## D√©tection de code barre

La premi√®re brique de notre application consiste √† rep√©rer un produit par le scan du code-barre. 
Nous allons partir pour le moment d'un produit d'exemple, ci-dessous: 

![](https://images.openfoodfacts.org/images/products/500/011/260/2791/front_fr.4.400.jpg)

```{python}
url_image = "https://images.openfoodfacts.org/images/products/500/011/260/2791/front_fr.4.400.jpg"
```

Dans le cadre de notre application, on permettra aux utilisateurs d'_uploader_ 
la photo d'un produit, ce sera plus _fun_.
En attendant notre application,
partir d'un produit standardis√©
permet d√©j√† de mettre en oeuvre la logique √† r√©-appliquer plus tard. 

Pour se simplifier la vie, le plus simple pour rep√©rer un code-barre est d'utiliser
le _package_ [`pyzbar`](https://pypi.org/project/pyzbar/).
Pour transformer une image en
matrice `Numpy` (l'objet attendu par [`pyzbar`](https://pypi.org/project/pyzbar/)),
on peut utiliser le module `skimage` de la mani√®re suivante:

```{python}
from skimage import io
io.imread(url_image)
```

Gr√¢ce √† `sklearn.image`, on peut utiliser
l'URL d'une page web ou le chemin d'un fichier de mani√®re indiff√©rente
pour la valeur de `url_image`. 


::: {.cell .markdown}
<!----- boite üü¢üîµüî¥ et ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Extraire le code-barre √† partir d'une image (üü¢üîµüî¥ et ‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Apr√®s avoir import√© l'image via `io.imread`, utiliser `pyzbar.decode`
pour extraire les informations voulues, notamment le code-barre. 
2. Si vous avez nomm√© l'objet g√©n√©r√©, v√©rifier le code-barre avec
`obj[0].data.decode()`.
3. A partir de cela, cr√©er une fonction `extract_ean` pour d√©coder l'image
(en retournant l'objet g√©n√©r√© par `pyzbar`)

```{=html}
</details>
</div>
```

<!----- end üü¢üîµüî¥ et ‚ö´ ----->
:::

```{python}
#| classes: yellow-code
#| label: get-openfood-parquet
#| output: false
#| eval: false
# Solution pour voie üü°
from pyzbar import pyzbar

def extract_ean(url, verbose=True):
    img = io.imread(url)
    decoded_objects = pyzbar.decode(img)
    if verbose is True:
        for obj in decoded_objects:
            # draw the barcode
            print("detected barcode:", obj)
            # print barcode type & data
            print("Type:", obj.type)
            print("Data:", obj.data)
    return decoded_objects

obj = extract_ean(url_image, verbose = False)

obj[0].data.decode()
```


```{python}
#| echo: false
from utils.detect_barcode import extract_ean
extract_ean(url_image)
```

On obtient bien un code identifiant notre produit. Il s'agit
de l'EAN qui est un identifiant unique, partag√© quelque soit
le point de vente d'un produit. Il s'agit d'un identifiant
pr√©sent sur tout code-barre, utilis√© 
dans les syst√®mes d'information 
des grandes enseignes mais aussi dans les bases produits
qui peuvent √™tre utilis√©es de mani√®re annexe (par exemple
l'`OpenFoodFacts`). 


## Association d'un code barre √† un produit d'openfoodfacts

Maintenant qu'on dispose d'un code-barre (le num√©ro EAN), 
on va trouver le produit dans `OpenFoodFacts`
√† partir de ce code-barre.

Cependant, comme il peut arriver
qu'un produit dispose d'informations incompl√®tes, 
il peut √™tre utile de faire non seulement de l'apparimeent
exact (trouver le produit avec le m√™me code EAN) mais aussi de
l'appariement flou (trouver un produit avec un nom proche de celui qu'on
veut). Ceci est un exercice pour les parcours üî¥ et ‚ö´, les autres
voies pouvant prendre cette fonction comme donn√©e. 

Voici l'EAN d'exemple :

```{python}
ean = "5000112602999"
```

Pour avoir un outil performant, on propose d'utiliser
`DuckDB` pour lire et filtrer les donn√©es. Cela sera plus performant que 
lire, √† chaque fois que l'utilisateur de notre applicatoin _upload_ une image,
un gros fichier (2 millions de ligne) pour n'en garder qu'une. 

Voici la configuration √† mettre en oeuvre:

```{python}
import duckdb
con = duckdb.connect(database=':memory:')
con.execute("""
    INSTALL httpfs;
    LOAD httpfs;
    SET s3_endpoint='minio.lab.sspcloud.fr'
""")

url_data = "https://projet-funathon.minio.lab.sspcloud.fr/2023/sujet4/diffusion/openfood.parquet"
```


::: {.cell .markdown}
<!----- boite üü¢üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Lire les donn√©es avec `DuckDB` (üü¢ et üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>

Pour ex√©cuter une requ√™te SQL, on utilise la structure suivante avec `DuckDB`

```python
data_pandas_from_duckdb = con.sql(REQUETE).df()
```

La requ√™te que nous proposons d'utiliser est √† structurer √† partir des √©l√©ments suivants :

- Pour la clause `SELECT`, la liste des colonnes √† utiliser est pr√©-formatt√©e dans l'objet `liste_colonnes_sql`
- Pour la clause `FROM`, l'instruction `read_parquet` peut √™tre utilis√©e avec l'URL stock√© dans `url_data`
- Pour la clause WHERE, vous pouvez utiliser la syntaxe suivante pour normaliser les code-barres des deux c√¥t√©s en retirant les 
0 initiaux: `CAST(ltrim(code, '0') AS STRING) = CAST(ltrim({ean}) AS STRING)`

```{=html}
</details>
</div>
```

<!----- end üü¢üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥ et ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Lire les donn√©es avec `DuckDB` (üî¥ et ‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>

La requ√™te que nous proposons d'utiliser est √† structurer √† partir des √©l√©ments suivants :

- Ne garder que les variables pr√©sentes dans `liste_colonnes_sql`
- Lire les donn√©es directement depuis `url_data`
- Filtrer les donn√©es pour ne garder que celle dans l'OpenFood avec notre code-barre

Aide pour la voie üî¥

Il faut normaliser les code-barres des deux c√¥t√©s avant d'essayer
de comparer. Cela se fait de la mani√®re suivante: `CAST(ltrim({ean}) AS STRING)`
A vous de mettre en oeuvre cela pour faire de la comparaison entre notre EAN et la
variable `code` 



```{=html}
</details>
</div>
```

<!----- end üî¥ et ‚ö´ ----->
:::


```{python}
# Solution pour voie üü°

import numpy as np
import pandas as pd
from utils.pipeline import clean_note

def fuzzy_matching_product(openfood_produit, product_name, con, url_data, liste_colonnes_sql, indices_synthetiques):
    out_textual = con.sql(f"SELECT {liste_colonnes_sql} from read_parquet('{url_data}') WHERE jaro_winkler_similarity('{product_name}',product_name) > 0.8 AND \"energy-kcal_100g\" IS NOT NULL")
    out_textual = out_textual.df()

    out_textual_imputed = pd.concat(
        [
            openfood_produit.loc[:, ["code", "product_name", "coicop"]].reset_index(drop = True),
            pd.DataFrame(out_textual.loc[:, indices_synthetiques].replace("NONE","").replace('',np.nan).mode(dropna=True))
        ], ignore_index=True, axis=1
    )
    out_textual_imputed.columns = ["code", "product_name", "coicop"] + indices_synthetiques
    
    return out_textual_imputed
```


```{python}
from utils.download_pb import import_coicop_labels
coicop = import_coicop_labels(
    "https://www.insee.fr/fr/statistiques/fichier/2402696/coicop2016_liste_n5.xls"
)
```

```{python}
# Solution pour voie üü°

def find_product_openfood(con, liste_colonnes_sql, url_data, ean):
    openfood_produit = con.sql(
        f"SELECT {liste_colonnes_sql} FROM read_parquet('{url_data}') WHERE CAST(ltrim(code, '0') AS STRING) = CAST(ltrim({ean}) AS STRING)"
    ).df()
    
    product_name = openfood_produit["product_name"].iloc[0]
    
    if openfood_produit['nutriscore_grade'].isin(['NONE','']).iloc[0]:
        openfood_produit = fuzzy_matching_product(
            openfood_produit, product_name, con, url_data,
            liste_colonnes_sql, indices_synthetiques)
        openfood_produit = openfood_produit.merge(coicop, left_on = "coicop", right_on = "Code")

    return openfood_produit
```

```{python}
openfood_produit = find_product_openfood(con, liste_colonnes_sql, url_data, ean)
```

## Production automatique d'un graphique

```{python}
stats_notes = pd.read_parquet("https://minio.lab.sspcloud.fr/projet-funathon/2023/sujet4/diffusion/stats_notes_pandas.parquet")
```

```{python}
from utils.construct_figures import figure_infos_notes

variable = 'nutriscore_grade'

def plot_product_info(
    data, variable,
    stats_notes):

    fig = figure_infos_notes(
        stats_notes,
        variable_note = variable,
        coicop = data['coicop'].iloc[0],
        note_produit = data[variable].iloc[0]
    )

    return fig
```

```{python}
#| output: false
fig = plot_product_info(openfood_produit, variable, stats_notes)
fig.update_layout(width=800, height=400)
fig
```


```{python}
#| output: false
fig = plot_product_info(openfood_produit, "ecoscore_grade", stats_notes)
fig.update_layout(width=800, height=400)
fig
```


## COICOP en API





```{python}
#| eval: false
#| echo: false
import requests

url_api = f"https://api.lab.sspcloud.fr/predicat/label?k=1&q=%27{product_name}%27"
url_api = url_api.replace(" ", "%20")


output_api_predicat = requests.get(url_api).json()
coicop_found = output_api_predicat['coicop'][f"'{product_name}'"][0]['label']
coicop_found
```

